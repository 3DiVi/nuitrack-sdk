<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Nuitrack: User Segment Visualization</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="nuitrack.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Nuitrack
   &#160;<span id="projectnumber">1.4.1</span>
   </div>
   <div id="projectbrief">3D Skeleton Tracking Middleware</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('UnitySegment_page.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Events</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">User Segment Visualization </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#segment_visualization">Visualizing a User Segment</a><ul><li class="level2"><a href="#segment_user_presence">Checking User Presence</a></li>
<li class="level2"><a href="#creating_segment">Creating and Rendering the User Segment</a></li>
</ul>
</li>
<li class="level1"><a href="#segment_game">Creating a Game with a User Segment</a><ul><li class="level2"><a href="#preparing_segment">Modifying a Segment for Interacting with Game Objects</a></li>
<li class="level2"><a href="#segment_game_objects">Creating a Segment with Game Objects</a></li>
<li class="level2"><a href="#create_falling_objects">Creating Falling Objects</a></li>
<li class="level2"><a href="#segment_scoring">Adding Scoring</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p>In this tutorial, you'll learn how to visualize a user segment using <b>Nuitrack SDK</b>. As a result, the user will be displayed as a colored 2D silhouette. And if there are several people in front of the camera, they will be displayed as several silhouettes of different colors. You can use the user segment for various purposes, for example, to create apps and games.</p>
<p>To create this project, you'll need just a couple of things: </p>
<ul>
<li>
Nuitrack Runtime and Nuitrack SDK </li>
<li>
Any supported sensor (see the complete list at <a href="https://nuitrack.com/">Nuitrack website</a>) </li>
<li>
Unity 2017.4 or higher </li>
</ul>
<p>You can find the finished project in <b>Nuitrack SDK</b>: <b>Unity 3D → NuitrackSDK.unitypackage → Tutorials → SegmentExample</b></p>
<div class="image">
<img src="Usegment_21.gif" alt="Usegment_21.gif"/>
</div>
 <h1><a class="anchor" id="segment_visualization"></a>
Visualizing a User Segment</h1>
<p>In this part of our tutorial, we'll describe the process of segment visualization. To create a user segment, you'll only need <b>Nuitrack SDK</b> and compatible sensor (for example, <a href="https://tvico.io/"><b>TVico</b></a>).</p>
<h2><a class="anchor" id="segment_user_presence"></a>
Checking User Presence</h2>
<ol>
<li>
<p class="startli">Before we begin to visualize the user segment, we first need to check whether the user is detected by the camera or not. First of all, import the <b>Nuitrack Prefab</b> from the <b>Nuitrack SDK</b> to your Unity project. Tick the Nuitrack modules required for this project (<b>Depth Module, User Tracker Module, Skeleton Tracker Module</b>). We'll need these very modules, because in our sample we'll use the depth data of the sensor, as well as the data about the users standing in front of the sensor.</p>
<div class="image">
<img src="Usegment_1.png" alt="Usegment_1.png"/>
<div class="caption">
Nuitrack Modules Required for this Project</div></div>
 <p class="endli"></p>
</li>
<li>
<p class="startli">Let's create a script and name it <em>SegmentPaint.cs</em>. This script will contain all the information about our user segment. In the <em>Start</em> method, subscribe to updating the frame with the user.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Start()</div>
<div class="line">{</div>
<div class="line">    NuitrackManager.onUserTrackerUpdate += ColorizeUser;</div>
<div class="line">}</div>
</div><!-- fragment --><p class="endli"></p>
</li>
<li>
<p class="startli">Create the <em>onDestroy</em> method, which occurs when a scene or game ends. Unsubscribe from the user frame update event to make sure that when you move to another Scene, no null reference will be created. You can learn more about Execution Order of Event Functions <a href="https://docs.unity3d.com/Manual/ExecutionOrder.html">here</a>.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> OnDestroy()</div>
<div class="line">{</div>
<div class="line">    NuitrackManager.onUserTrackerUpdate -= ColorizeUser;</div>
<div class="line">}</div>
</div><!-- fragment --><p class="endli"></p>
</li>
<li>
<p class="startli">Process the received frames and check the presence of the user in front of the sensor. First of all, declare the <em>msg</em> variable for displaying either 'User found' (if there is at least one user in front of the camera) or 'User not found' message. The condition is processed in the <em>ColorizeUser</em> method. Also, don't forget to set the characteristics of the 'User found / User not found' message (color and size) in the <em>OnGUI</em> method.</p>
<div class="fragment"><div class="line"><span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;&quot;</span>;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> ColorizeUser(nuitrack.UserFrame frame)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (frame.Users.Length &gt; 0)</div>
<div class="line">        msg = <span class="stringliteral">&quot;User found&quot;</span>;</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">        msg = <span class="stringliteral">&quot;User not found&quot;</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span> <span class="keywordtype">void</span> OnGUI()</div>
<div class="line">{</div>
<div class="line">    GUI.color = Color.red;</div>
<div class="line">    GUI.skin.label.fontSize = 50;</div>
<div class="line">    GUILayout.Label(msg);</div>
<div class="line">}</div>
</div><!-- fragment --><p class="endli"></p>
</li>
<li>
Drag-and-drop the <em>SegmentPaint.cs</em> script to the <b>Main Camera</b>. </li>
<li>
Run the project and check the presence of the user. If everything is okay, you will see the 'User found' message on the screen when you are standing in front of the camera. Once you have checked that everything works just fine, let's proceed to the next stage. </li>
</ol>
<div class="image">
<img src="Usegment_2.png" alt="Usegment_2.png"/>
<div class="caption">
'User found' message displayed</div></div>
 <h2><a class="anchor" id="creating_segment"></a>
Creating and Rendering the User Segment</h2>
<ol>
<li>
On the Scene, create a <b>Canvas</b> that will be used for displaying the user segment: <b>GameObject → UI → Canvas</b>. </li>
<li>
<p class="startli">The <b>Main Camera</b> settings remain default.</p>
<dl class="section note"><dt>Note</dt><dd>You can select either <b>Orthographic</b> or <b>Perspective</b> camera projection because the canvas size will in any case be automatically adjusted.</dd></dl>
</li>
<li>
<p class="startli">Add a game object for displaying the user segment to the <b>Canvas</b>: <b>Game Object → UI → Image</b> and name it <b>Segment</b>. The size of this object should coincide with the <b>Canvas</b> size. Stretch the width of this object so that it coincides with the <b>Canvas</b>. Make sure that <b>Rect Transform</b> settings are set as shown in the picture below.</p>
<div class="image">
<img src="Usegment_3.png" alt="Usegment_3.png"/>
<div class="caption">
Segment Settings</div></div>
 <p class="endli"></p>
</li>
<li>
<p class="startli">In the <em>GameSegment.cs</em> script, create the <em>Color32</em> array, which stands for the colors used for colorizing the users, the <em>Rect</em> field, which stands for a rectangular used for framing the sprite in the image, the <em>Image</em> field, which stands for the image displayed on the canvas, the <em>Texture2D</em>, which is a texture used for displaying the segment, the <em>Sprite</em> for a sprite, the <em>byte</em> array for processing the sensor input data, as well as <em>cols</em> and <em>rows</em> for displaying the matrix of segments.</p>
<div class="fragment"><div class="line"><span class="keyword">public</span> <span class="keyword">class </span>SegmentPaint : MonoBehaviour</div>
<div class="line">{</div>
<div class="line">    [SerializeField]</div>
<div class="line">    Color32[] colorsList;</div>
<div class="line">     </div>
<div class="line">    Rect imageRect;</div>
<div class="line">     </div>
<div class="line">    [SerializeField]</div>
<div class="line">    Image segmentOut;</div>
<div class="line">     </div>
<div class="line">    Texture2D segmentTexture;</div>
<div class="line">    Sprite segmentSprite;</div>
<div class="line">    byte[] outSegment;</div>
<div class="line">     </div>
<div class="line">    <span class="keywordtype">int</span> cols = 0;</div>
<div class="line">    <span class="keywordtype">int</span> rows = 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p class="endli"></p>
</li>
<li>
<p class="startli">Mirror the image received from the sensor using the <em>SetMirror</em> method in the <em>Start</em> method.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Start()</div>
<div class="line">{</div>
<div class="line">    NuitrackManager.DepthSensor.SetMirror(<span class="keyword">true</span>);</div>
<div class="line">}</div>
</div><!-- fragment --><p class="endli"></p>
</li>
<li>
<p class="startli">Request the output image parameters from the depth sensor.</p>
<div class="fragment"><div class="line">...</div>
<div class="line">nuitrack.OutputMode mode = NuitrackManager.DepthSensor.GetOutputMode();</div>
<div class="line">cols = mode.XRes;</div>
<div class="line">rows = mode.YRes;</div>
<div class="line">...</div>
</div><!-- fragment --><p class="endli"></p>
</li>
<li>
<p class="startli">Create the <em>Rect</em> rectangle to define the texture boundaries.</p>
<div class="fragment"><div class="line">... </div>
<div class="line">imageRect = <span class="keyword">new</span> Rect(0, 0, cols, rows);</div>
<div class="line">...</div>
</div><!-- fragment --><p class="endli"></p>
</li>
<li>
<p class="startli">Create a segment texture and specify its width and height. Set <b>ARGB32</b> format for the texture because this format supports an Alpha channel, 1 byte (8 bits) per each channel (all in all, there are 4 channels). We need the Alpha channel so we can make the areas without a user transparent. You can learn more about the ARGB32 format <a href="https://docs.unity3d.com/ScriptReference/TextureFormat.ARGB32.html">here</a>.</p>
<div class="fragment"><div class="line">...</div>
<div class="line">segmentTexture = <span class="keyword">new</span> Texture2D(cols, rows, TextureFormat.ARGB32, <span class="keyword">false</span>);</div>
<div class="line">...</div>
</div><!-- fragment --><p class="endli"></p>
</li>
<li>
<p class="startli">Create an output segment and specify its size in bytes. Multiply the image size by 4 because there are 4 channels (ARGB32) in every pixel.</p>
<div class="fragment"><div class="line">...</div>
<div class="line">outSegment = <span class="keyword">new</span> byte[cols * rows * 4];</div>
<div class="line">...</div>
</div><!-- fragment --><p class="endli"></p>
</li>
<li>
<p class="startli">Set the <em>Image</em> type to <em>Simple</em> as our image should be displayed in regular mode (no stretching, etc.), and set the <em>preserveAspect = true</em> flag so that the image retains the aspect ratio.</p>
<div class="fragment"><div class="line">... </div>
<div class="line">segmentOut.type = Image.Type.Simple;</div>
<div class="line">segmentOut.preserveAspect = <span class="keyword">true</span>;</div>
<div class="line">...</div>
</div><!-- fragment --><p class="endli"></p>
</li>
<li>
<p class="startli">In the <em>ColorizeUser</em> method, process the input data in the <em>for (int i = 0; i &lt; (cols * rows); i++)</em> loop. Take the i-th user, his/her id (0, 1, 2, 3...), and paint the pixels in color, which corresponds to the user id. As a result, we get an array with colors, which correspond to users (from 1 to 6) represented in a form of bytes.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> ColorizeUser(nuitrack.UserFrame frame)</div>
<div class="line">... </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; (cols * rows); i++)</div>
<div class="line">    {</div>
<div class="line">        Color32 currentColor = colorsList[frame[i]];</div>
<div class="line">     </div>
<div class="line">        <span class="keywordtype">int</span> ptr = i * 4;</div>
<div class="line">        outSegment[ptr] = currentColor.a;</div>
<div class="line">        outSegment[ptr + 1] = currentColor.r;</div>
<div class="line">        outSegment[ptr + 2] = currentColor.g;</div>
<div class="line">        outSegment[ptr + 3] = currentColor.b;</div>
<div class="line">    }</div>
</div><!-- fragment --><p class="endli"></p>
</li>
<li>
<p class="startli">Pass an array for texture filling and apply it.</p>
<div class="fragment"><div class="line">... </div>
<div class="line">segmentTexture.LoadRawTextureData(outSegment);</div>
<div class="line">segmentTexture.Apply();</div>
<div class="line">...</div>
</div><!-- fragment --><p class="endli"></p>
</li>
<li>
<p class="startli">Apply the texture to the sprite. As arguments, specify the texture, rectangle, offset (multiply Vector3 by 0.5 to set the image center), texture detail, extrude (amount by which the sprite mesh should be expanded outwards), mesh type. As we use the <b>FullRect</b> mesh type, the size of the sprite would increase, but the processing time is significantly reduced. You can learn more about the <em>Sprite.Create</em> parameters <a href="https://docs.unity3d.com/ScriptReference/Sprite.Create.html">here</a>.</p>
<div class="fragment"><div class="line">...</div>
<div class="line">segmentSprite = Sprite.Create(segmentTexture, imageRect, Vector3.one * 0.5f, 100f, 0, SpriteMeshType.FullRect);</div>
<div class="line">...</div>
</div><!-- fragment --><p class="endli"></p>
</li>
<li>
<p class="startli">Apply the <em>Sprite</em> to the <em>Image</em>. A new sprite will be created in each frame, however, it won't affect the performance. So, it does not matter whether you use texture for a sprite or for a material.</p>
<div class="fragment"><div class="line">...</div>
<div class="line">segmentOut.sprite = segmentSprite;</div>
<div class="line">...</div>
</div><!-- fragment --><p class="endli"></p>
</li>
<li>
<p class="startli">In Unity, configure the <b>Segment Paint (Script)</b>. Set the colors for coloring the segments. The first color should be transparent (Alpha = 0) as it is used when the user is not found. As for the other 6 colors, you can select any colors you want. All in all, you should select 7 colors. In the <b>Segment Out</b> settings, make a reference to the <b>Segment Image</b> from the <b>Canvas</b>.</p>
<div class="image">
<img src="Usegment_4.png" alt="Usegment_4.png"/>
<div class="caption">
Selected Colors</div></div>
 <p class="endli"></p>
</li>
<li>
<p class="startli">Run the project. At this stage, you should see a colored user segment on the screen.</p>
<div class="image">
<img src="Usegment_5.gif" alt="Usegment_5.gif"/>
<div class="caption">
User Segment</div></div>
  </li>
</ol>
<p>Congratulations, you've just visualized a user segment using <b>Nuitrack SDK</b>! Now you can use it to create various apps and games. If you want to learn how to create a game in Unity using this segment, check out the second part of this tutorial.</p>
<h1><a class="anchor" id="segment_game"></a>
Creating a Game with a User Segment</h1>
<p>In this section of our tutorial, we are going to make a simple game, in which the user is displayed as a segment and your goal is to destroy as much objects falling from the top as you can. You get points for each falling object that you destroyed. If you miss the object and it touches the bottom line, you lose points. You can create this game even if you don't have much experience with Unity.</p>
<h2><a class="anchor" id="preparing_segment"></a>
Modifying a Segment for Interacting with Game Objects</h2>
<ol>
<li>
<p class="startli">Let's change the <b>Canvas</b> settings. Change its position so that the <b>Canvas</b> is located not over the screen but in front of the camera: <b>Main Camera → Camera → Screen Space</b>. Now the <b>Canvas</b> moves in accordance with the camera movement. Set the distance so that the <b>Canvas</b> is in the scope of the camera.</p>
<div class="image">
<img src="Usegment_6.png" alt="Usegment_6.png"/>
<div class="caption">
Canvas Settings</div></div>
 <p class="endli"></p>
</li>
<li>
Now we have to attach colliders to our segment, which will interact with other game objects. Let's describe the colliders behavior in a new script named <em>GameColliders.cs</em>. </li>
<li>
<p class="startli">In the <em>GameColliders</em> class, create the necessary fields:</p>
<div class="fragment"><div class="line"><span class="keyword">public</span> <span class="keyword">class </span>GameColliders : MonoBehaviour</div>
<div class="line">{</div>
<div class="line">    [SerializeField]</div>
<div class="line">    Transform parentObject; <span class="comment">// parent object for colliders</span></div>
<div class="line">     </div>
<div class="line">    [SerializeField]</div>
<div class="line">    GameObject userPixelPrefab; <span class="comment">// object that acts as a user pixel</span></div>
<div class="line">    [SerializeField]</div>
<div class="line">    GameObject bottomLinePrefab; <span class="comment">// bottom line object </span></div>
<div class="line">     </div>
<div class="line">    GameObject[,] colliderObjects; <span class="comment">// matrix of colliders (game objects)</span></div>
<div class="line">     </div>
<div class="line">    <span class="keywordtype">int</span> cols = 0; <span class="comment">// columns to display the matrix </span></div>
<div class="line">    <span class="keywordtype">int</span> rows = 0; <span class="comment">// rows to display the matrix </span></div>
<div class="line">     </div>
<div class="line">    [Range (0.1f, 1)]</div>
<div class="line">    [SerializeField]</div>
<div class="line">    <span class="keywordtype">float</span> colliderDetails = 1f; <span class="comment">// set the detail of colliders</span></div>
<div class="line">}</div>
</div><!-- fragment --><p class="endli"></p>
</li>
<li>
<p class="startli">Create the <em>CreateColliders</em> public method, which takes the input data (number of columns and rows) from the sensor. In this method, calculate the new size of colliders in accordance with the level of detail of colliders, that we've set (<em>colliderDetails</em>) by multiplying the number of columns and rows to the level of detail.</p>
<div class="fragment"><div class="line"><span class="keyword">public</span> <span class="keywordtype">void</span> CreateColliders(<span class="keywordtype">int</span> imageCols, <span class="keywordtype">int</span> imageRows)</div>
<div class="line">{</div>
<div class="line">    cols = (int)(colliderDetails * imageCols);</div>
<div class="line">    rows = (int)(colliderDetails * imageRows);</div>
<div class="line">}</div>
</div><!-- fragment --><p class="endli"></p>
</li>
<li>
<p class="startli">Create an array of objects and set its size.</p>
<div class="fragment"><div class="line">... </div>
<div class="line">colliderObjects = <span class="keyword">new</span> GameObject[cols, rows];</div>
<div class="line">...</div>
</div><!-- fragment --><p class="endli"></p>
</li>
<li>
<p class="startli">Using the <em>imageScale</em> variable, scale the size of the matrix of colliders and the image. The image will be aligned either by width or by height, depending on the image received from the sensor. You can learn more about properties of the <em>Screen</em> class <a href="https://docs.unity3d.com/ScriptReference/Screen.html">here</a>.</p>
<div class="fragment"><div class="line">...</div>
<div class="line">float imageScale = Mathf.Min((<span class="keywordtype">float</span>)Screen.width / cols, (<span class="keywordtype">float</span>)Screen.height / rows);</div>
<div class="line">...</div>
</div><!-- fragment --><p class="endli"></p>
</li>
<li>
<p class="startli">Fill the array with objects in a loop.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> c = 0; c &lt; cols; c++)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> r = 0; r &lt; rows; r++)</div>
<div class="line">    {</div>
<div class="line">        GameObject currentCollider = Instantiate(userPixelPrefab); <span class="comment">// create an object from UserPixel</span></div>
<div class="line">         </div>
<div class="line">        currentCollider.transform.SetParent(parentObject, <span class="keyword">false</span>); <span class="comment">// set a parent</span></div>
<div class="line">        currentCollider.transform.localPosition = <span class="keyword">new</span> Vector3((cols / 2 - c) * imageScale, (rows / 2 - r) * imageScale, 0); <span class="comment">// update the local position, arrange pixel objects relative to the Image center</span></div>
<div class="line">        currentCollider.transform.localScale = Vector3.one * imageScale; <span class="comment">// set the scale to make it larger </span></div>
<div class="line">         </div>
<div class="line">        colliderObjects[c, r] = currentCollider; <span class="comment">// put a collider into the matrix of colliders  </span></div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p class="endli"></p>
</li>
<li>
<p class="startli">Create a bottom line and set up its characteristics just like with the <em>UserPixel</em>: set its parent, define its position and scale.</p>
<div class="fragment"><div class="line">...</div>
<div class="line">GameObject bottomLine = Instantiate(bottomLinePrefab);</div>
<div class="line">bottomLine.transform.SetParent(parentObject, <span class="keyword">false</span>);</div>
<div class="line">bottomLine.transform.localPosition = <span class="keyword">new</span> Vector3(0, -(rows / 2) * imageScale, 0);</div>
<div class="line">bottomLine.transform.localScale = <span class="keyword">new</span> Vector3(imageScale * cols, imageScale, imageScale); <span class="comment">// stretch by the image width </span></div>
<div class="line">...</div>
</div><!-- fragment --><p class="endli"></p>
</li>
<li>
<p class="startli">In the <em>SegmentPaint</em> script, add the <em>gameColliders</em> field for passing the image width and height.</p>
<div class="fragment"><div class="line">... </div>
<div class="line">[SerializeField]</div>
<div class="line">GameColliders gameColliders;</div>
<div class="line">...</div>
</div><!-- fragment --><p class="endli"></p>
</li>
<li>
<p class="startli">In this script, call the <em>gameColliders</em> method (pass the columns and rows) in the <em>Start</em> method to create colliders.</p>
<div class="fragment"><div class="line">...</div>
<div class="line">gameColliders.CreateColliders(cols, rows);</div>
<div class="line">...</div>
</div><!-- fragment --><p class="endli"></p>
</li>
<li>
In Unity, create two prefabs for displaying the bottom line (we named it 'BottomLine') and pixels for creating the user's silhouette (we named it 'UserPixel'). They should be in the form of a cube. For convenience, make them in different colors (for example, red for the bottom line and yellow for the pixel). Add the <b>Rigidbody</b> component for the user pixel object and tick <b>Is Kinematic</b> so that physics does not affect it during collision with other objects. </li>
<li>
<p class="startli">Drag-and-drop the <b>GameColliders</b> script to the camera. In Unity, specify the <b>userPixelPrefab</b> and <b>bottomLinePrefab</b> for the script. Drag-and-drop the <b>Canvas</b> to the <b>parentObject</b>. Specify the level of details in <b>colliderDetails</b> by selecting a number in the range from 0 to 1 (the lower it is, the higher the performance is).</p>
<div class="image">
<img src="Usegment_7.png" alt="Usegment_7.png"/>
<div class="caption">
Game Colliders (Script) Settings</div></div>
 <p class="endli"></p>
</li>
<li>
<p class="startli">In the <b>SegmentPaint</b>, make a reference to the <b>GameColliders</b>.</p>
<div class="image">
<img src="Usegment_8.png" alt="Usegment_8.png"/>
<div class="caption">
Reference to GameColliders </div></div>
 <p class="endli"></p>
</li>
<li>
Run the project and check that game objects are created correctly. At this stage, you won't see the segment because the <b>Canvas</b> is yet completely covered by colliders. The bottom line is displayed. </li>
</ol>
<div class="image">
<img src="Usegment_9.png" alt="Usegment_9.png"/>
<div class="caption">
Canvas covered by created Colliders</div></div>
 <h2><a class="anchor" id="segment_game_objects"></a>
Creating a Segment with Game Objects</h2>
<ol>
<li>
<p class="startli">In the <em>GameColliders.cs</em> script, create the <em>UpdateFrame</em> method. If a user is in the frame, the game objects for displaying the silhouette are activated, otherwise, they are hidden.</p>
<div class="fragment"><div class="line"><span class="keyword">public</span> <span class="keywordtype">void</span> UpdateFrame(nuitrack.UserFrame frame) <span class="comment">// update the frame</span></div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> c = 0; c &lt; cols; c++) <span class="comment">// loop over the columns</span></div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> r = 0; r &lt; rows; r++) <span class="comment">// loop over the rows </span></div>
<div class="line">        {</div>
<div class="line">            ushort userId = frame[(int)(r / colliderDetails), (int)(c / colliderDetails)]; <span class="comment">// request a user id according to colliderDetails </span></div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">if</span> (userId == 0)</div>
<div class="line">                colliderObjects[c, r].SetActive(<span class="keyword">false</span>);</div>
<div class="line">            <span class="keywordflow">else</span></div>
<div class="line">                colliderObjects[c, r].SetActive(<span class="keyword">true</span>);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p class="endli"></p>
</li>
<li>
<p class="startli">Call this method in the <em>ColorizeUser</em> method of the <em>SegmentPaint</em> script.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> ColorizeUser(nuitrack.UserFrame frame)</div>
<div class="line">{</div>
<div class="line">...</div>
<div class="line">    gameColliders.UpdateFrame(frame);</div>
<div class="line">}</div>
<div class="line">...</div>
</div><!-- fragment --><p class="endli"></p>
</li>
<li>
<p class="startli">If you run the project at this stage, the user silhouette is displayed as a texture. You can see game objects that overlap the texture.</p>
<div class="image">
<img src="Usegment_10.gif" alt="Usegment_10.gif"/>
<div class="caption">
User Segment overlapped by Game Objects</div></div>
 <p class="endli"></p>
</li>
<li>
<p class="startli">In Unity, untick the <b>Mesh Renderer</b> component from the <b>UserPixel</b> prefab so that the cube mesh is not rendered (the cube will be transparent).</p>
<div class="image">
<img src="Usegment_11.png" alt="Usegment_11.png"/>
<div class="caption">
Unticked Mesh Renderer Component</div></div>
 <p class="endli"></p>
</li>
<li>
Run the project and check that the segment is displayed without colliders (as a texture). </li>
</ol>
<div class="image">
<img src="Usegment_12.png" alt="Usegment_12.png"/>
<div class="caption">
User Segment without Colliders</div></div>
 <h2><a class="anchor" id="create_falling_objects"></a>
Creating Falling Objects</h2>
<ol>
<li>
<p class="startli">Create a new script named <em>ObjectSpawner.cs</em>. In this script, create an array with objects: <em>GameObject[] fallingObjects</em>. Specify the minimum (1 sec) and maximum (2 sec) time interval between falling of objects. The <em>halfWidth</em> variable defines the distance from the center of the image to one of its edges in width.</p>
<div class="fragment"><div class="line"><span class="keyword">public</span> <span class="keyword">class </span>ObjectSpawner : MonoBehaviour</div>
<div class="line">{</div>
<div class="line">    [SerializeField]</div>
<div class="line">    GameObject[] fallingObjects;</div>
<div class="line">     </div>
<div class="line">    [Range(0.5f, 2f)]</div>
<div class="line">    [SerializeField]</div>
<div class="line">    <span class="keywordtype">float</span> minTimeInterval = 1;</div>
<div class="line">     </div>
<div class="line">    [Range(2f, 4f)]</div>
<div class="line">    [SerializeField]</div>
<div class="line">    <span class="keywordtype">float</span> maxTimeInterval = 2;</div>
<div class="line">     </div>
<div class="line">    <span class="keywordtype">float</span> halfWidth;</div>
<div class="line">}</div>
</div><!-- fragment --><p class="endli"></p>
</li>
<li>
<p class="startli">Create the <em>StartSpawn</em> method. Get original image width and start a coroutine.</p>
<div class="fragment"><div class="line"><span class="keyword">public</span> <span class="keywordtype">void</span> StartSpawn(<span class="keywordtype">float</span> widthImage)</div>
<div class="line">{</div>
<div class="line">    halfWidth = widthImage / 2;</div>
<div class="line">    StartCoroutine(SpawnObject(0f));</div>
<div class="line">}</div>
</div><!-- fragment --><p class="endli"></p>
</li>
<li>
<p class="startli">Let's describe the coroutine contents.</p>
<div class="fragment"><div class="line">IEnumerator SpawnObject(<span class="keywordtype">float</span> waitingTime)</div>
<div class="line">{</div>
<div class="line">    yield <span class="keywordflow">return</span> <span class="keyword">new</span> WaitForSeconds(waitingTime); <span class="comment">// delay </span></div>
<div class="line">     </div>
<div class="line">    <span class="keywordtype">float</span> randX = Random.Range(-halfWidth, halfWidth); <span class="comment">// random X position</span></div>
<div class="line">    Vector3 localSpawnPosition = <span class="keyword">new</span> Vector3(randX, 0, 0); <span class="comment">// position for object spawning </span></div>
<div class="line">     </div>
<div class="line">    GameObject currentObject = Instantiate(fallingObjects[Random.Range(0, fallingObjects.Length)]); <span class="comment">// create a random object from the array</span></div>
<div class="line">     </div>
<div class="line">    currentObject.transform.SetParent(gameObject.transform, <span class="keyword">true</span>); <span class="comment">// set a parent </span></div>
<div class="line">    currentObject.transform.localPosition = localSpawnPosition; <span class="comment">// set a local position</span></div>
<div class="line">     </div>
<div class="line">    StartCoroutine(SpawnObject(Random.Range(minTimeInterval, maxTimeInterval))); <span class="comment">// restart the coroutine for the next object</span></div>
<div class="line">} </div>
</div><!-- fragment --><p class="endli">Objects will fall from the top in a random number of seconds in the range of [minimum time interval ... maximum time interval]. You can learn more about the <em>Random</em> class <a href="https://docs.unity3d.com/ScriptReference/Random.html">here</a>. </p>
</li>
<li>
<p class="startli">In Unity, create an empty object, drag-and-drop it to the <b>Canvas</b>, add the <b>Rectangle Transform</b> component so that this object is always located at the top of the <b>Canvas</b>. Perform top center alignment. After that, drag-and-drop <b>ObjectSpawner</b> to this object. This object will determine the point, which is used to calculate the start position of object falling.</p>
<div class="image">
<img src="Usegment_13.png" alt="Usegment_13.png"/>
<div class="caption">
ObjectSpawner Settings</div></div>
 <p class="endli"></p>
</li>
<li>
<p class="startli">In Unity, create two prefabs: <b>Capsule</b> and <b>Cube</b>, which will be used for displaying the game objects falling from the top. The user has to 'destroy' these objects. Add the <b>RigidBody</b> component to these prefabs. Drag-and-drop the objects to the <b>ObjectSpawner</b> section of the <b>MainCamera</b>. Fill in the <em>fallingObjects</em> array with the created prefabs.</p>
<div class="image">
<img src="Usegment_14.png" alt="Usegment_14.png"/>
<div class="caption">
Specified Capsule and Cube</div></div>
 <dl class="section note"><dt>Note</dt><dd>The speed of falling objects is regulated by adjusting the air resistance of prefabs: <b>RigidBody → Drag</b>. The lower the value, the lower the air resistance (0 - no resistance).</dd></dl>
</li>
<li>
<p class="startli">Drag-and-drop the prefabs to the <b>Canvas → ObjectSpawner</b>.</p>
<div class="image">
<img src="Usegment_15.png" alt="Usegment_15.png"/>
<div class="caption">
Falling Objects specified for Object Spawner</div></div>
 <p class="endli"></p>
</li>
<li>
<p class="startli">In the <em>SegmentPaint</em> script, add the <em>ObjectSpawner</em> field to pass the parameters and run.</p>
<div class="fragment"><div class="line">...</div>
<div class="line">[SerializeField]</div>
<div class="line">ObjectSpawner objectSpawner;</div>
<div class="line">...</div>
</div><!-- fragment --><p class="endli"></p>
</li>
<li>
<p class="startli">In the <em>Start</em> method, pass the parameters to <em>GameObjectSpawner</em>.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Start()</div>
<div class="line">{</div>
<div class="line">...</div>
<div class="line">    gameColliders.CreateColliders(cols, rows);</div>
<div class="line">    objectSpawner.StartSpawn(cols);</div>
<div class="line">}</div>
<div class="line">...</div>
</div><!-- fragment --><p class="endli"></p>
</li>
<li>
<p class="startli">Create a script named <em>FallingObjects.cs</em>, in which we'll define the condition for destruction our falling objects in a collision with other objects. Create the <em>OnCollisionEnter</em> method and call the <em>Destroy</em> method. We use this method because in our game the falling objects are destroyed in a collision with any object.</p>
<div class="fragment"><div class="line"><span class="keyword">private</span> <span class="keywordtype">void</span> OnCollisionEnter(Collision collision)</div>
<div class="line">{</div>
<div class="line">    Destroy(gameObject);</div>
<div class="line">}</div>
</div><!-- fragment --><p class="endli"></p>
</li>
<li>
In Unity, drag-and-drop this script to the falling objects (<b>Capsule, Cube</b>). </li>
<li>
<p class="startli">Make a reference to the <b>ObjectSpawner</b> and to <b>MainCamera</b> in <b>SegmentPaint</b>.</p>
<div class="image">
<img src="Usegment_16.png" alt="Usegment_16.png"/>
<div class="caption">
Segment Paint (Script) Settings</div></div>
 <p class="endli"></p>
</li>
<li>
Run the project. You should see the objects falling from the top and destroyed in a collision with the user segment or bottom line. </li>
</ol>
<div class="image">
<img src="Usegment_17.gif" alt="Usegment_17.gif"/>
<div class="caption">
User Segment and Falling Objects</div></div>
 <h2><a class="anchor" id="segment_scoring"></a>
Adding Scoring</h2>
<ol>
<li>
So, we added a game element to our project but it still doesn't really look like a game. To make our simple game a little bit more interesting, let's introduce scoring for missed / caught objects. To do that, create a new script named <em>GameProgress.cs</em>. This script will contain all the settings connected to scoring in our game. </li>
<li>
<p class="startli">In this script, create the fields that define a singleton (creates a reference to itself) so that the falling objects can call the methods of this class without having a direct reference to it, as well as the fields for the output text and the number of points added / subtracted when colliding with objects. You can learn more about Singleton <a href="https://msdn.microsoft.com/en-us/library/ff650316.aspx">here</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">public</span> <span class="keyword">class </span>GameProgress : MonoBehaviour</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> GameProgress instance = null;</div>
<div class="line">     </div>
<div class="line">    [SerializeField]</div>
<div class="line">    Text scoreText;</div>
<div class="line">     </div>
<div class="line">    <span class="keywordtype">int</span> currentScore = 0;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> Awake()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (instance == null)</div>
<div class="line">        instance = <span class="keyword">this</span>;</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (instance != <span class="keyword">this</span>)</div>
<div class="line">        Destroy(gameObject);</div>
<div class="line">}</div>
</div><!-- fragment --><p class="endli"></p>
</li>
<li>
<p class="startli">Create the <em>UpdateScoreText</em> method, which stands for updating the text.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> UpdateScoreText()</div>
<div class="line">{</div>
<div class="line">    scoreText.text = <span class="stringliteral">&quot;Your score: &quot;</span> + currentScore;</div>
<div class="line">}</div>
</div><!-- fragment --><p class="endli"></p>
</li>
<li>
<p class="startli">Add the <em>AddScore</em> and <em>RemoveScore</em> static methods, which define the addition and subtraction of points, respectively.</p>
<div class="fragment"><div class="line"><span class="keyword">public</span> <span class="keywordtype">void</span> AddScore(<span class="keywordtype">int</span> val)</div>
<div class="line">{</div>
<div class="line">    currentScore += val;</div>
<div class="line">    UpdateScoreText();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">public</span> <span class="keywordtype">void</span> RemoveScore(<span class="keywordtype">int</span> val)</div>
<div class="line">{</div>
<div class="line">    currentScore -= val;</div>
<div class="line">    UpdateScoreText();</div>
<div class="line">}</div>
</div><!-- fragment --><p class="endli"></p>
</li>
<li>
<p class="startli">In the <em>FallingObject.cs</em> script, add the <em>ScoreValue</em> field that defines the amount of points to be added / subtracted.</p>
<div class="fragment"><div class="line">...</div>
<div class="line">[SerializeField]</div>
<div class="line"><span class="keywordtype">int</span> scoreValue = 5;</div>
<div class="line">...</div>
</div><!-- fragment --><p class="endli"></p>
</li>
<li>
<p class="startli">In the <em>OnCollisionEnter</em> method, we add a tag check to define that points should be added when the user has 'caught' the falling object, and decreased when the object was 'missed' and fell onto the bottom line. Besides, you have to set the <em>active</em> flag to avoid multiple registration when the user's silhouette touches the falling object. Learn more about the <em>Destroy</em> method <a href="https://docs.unity3d.com/ScriptReference/Object.Destroy.html">here</a>.</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> active = <span class="keyword">true</span>;</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span> <span class="keywordtype">void</span> OnCollisionEnter(Collision collision)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (!active)</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line">    active = <span class="keyword">false</span>; </div>
<div class="line"></div>
<div class="line">    Destroy(gameObject);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (collision.transform.tag == <span class="stringliteral">&quot;UserPixel&quot;</span>)</div>
<div class="line">        GameProgress.AddScore(scoreValue);</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (collision.transform.tag == <span class="stringliteral">&quot;BottomLine&quot;</span>)</div>
<div class="line">        GameProgress.RemoveScore(scoreValue);</div>
<div class="line">}</div>
</div><!-- fragment --><p class="endli"></p>
</li>
<li>
<p class="startli">In Unity, set the relevant tags for the <b>UserPixel</b> and <b>BottomLine</b> prefabs: <b>Add Tag → UserPixel / BottomLine</b>.</p>
<div class="image">
<img src="Usegment_18.png" alt="Usegment_18.png"/>
<div class="caption">
Tags required for Prefabs</div></div>
 <p class="endli"></p>
</li>
<li>
<p class="startli">Create a text field on the canvas: <b>Game Object → UI → Text</b> (place the text field wherever you want).</p>
<div class="image">
<img src="Usegment_19.png" alt="Usegment_19.png"/>
<div class="caption">
New Text Field</div></div>
 <p class="endli"></p>
</li>
<li>
<p class="startli">Drag-and-drop the <b>GameProgress (Script)</b> to the <b>Main Camera</b>. Drag-and-drop the <b>Text</b> that we've just created to the <b>ScoreText</b> for displaying the text on the screen.</p>
<div class="image">
<img src="Usegment_20.png" alt="Usegment_20.png"/>
<div class="caption">
Specified Text Field</div></div>
 <p class="endli"></p>
</li>
<li>
Run the project. You should see that now points are added when you destroy the falling objects. If the objects fall on the bottom line, the points are subtracted. </li>
</ol>
<div class="image">
<img src="Usegment_21.gif" alt="Usegment_21.gif"/>
<div class="caption">
Final Game with a User Segment and Scoring</div></div>
  </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="UnityTutorials_page.html">Unity Tutorials</a></li>
    <li class="footer">Generated on Thu Aug 22 2019 12:41:45 for Nuitrack by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
